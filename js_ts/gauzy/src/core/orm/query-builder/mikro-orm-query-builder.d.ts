import { EntityRepository, QueryBuilder } from '@mikro-orm/knex';
import { IQueryBuilder } from './iquery-builder';
import { EntityTarget, FindManyOptions } from 'typeorm';
export declare class MikroOrmQueryBuilder<Entity extends object> implements IQueryBuilder<Entity> {
    private readonly repository;
    readonly queryAlias?: string;
    private qb;
    private orderCriteria;
    private groupByFields;
    private havingConditions;
    private havingParameters;
    get alias(): string;
    constructor(repository: EntityRepository<Entity>, queryAlias?: string);
    setQueryBuilder(qb: QueryBuilder<Entity>): this;
    getQueryBuilder(): QueryBuilder<Entity>;
    clone(): this;
    subQuery(): IQueryBuilder<Entity>;
    setFindOptions(findOptions: FindManyOptions<Entity>): this;
    select(selection: string, selectionAliasName?: string): this;
    distinct(isDistinct?: boolean): this;
    addSelect(selection: string, selectionAliasName?: string): this;
    from(entityTarget: ((qb: QueryBuilder<any>) => QueryBuilder<any>) | EntityTarget<Entity>, aliasName?: string): this;
    addFrom(_entityTarget: ((qb: QueryBuilder<any>) => QueryBuilder<any>) | EntityTarget<Entity>, _aliasName?: string): this;
    innerJoin(propertyPath: string, alias: string, condition?: any): this;
    innerJoinAndSelect(propertyPath: string, alias: string, condition?: any): this;
    leftJoin(propertyPath: string, alias: string, condition?: any): this;
    leftJoinAndSelect(propertyPath: string, alias: string, condition?: any): this;
    private handleWhereSubQuery;
    private handleWhereBracketsSubQuery;
    where(condition: string | object | ((qb: IQueryBuilder<Entity>) => IQueryBuilder<Entity>), parameters?: Record<string, any>): this;
    andWhere(condition: string | object | ((qb: IQueryBuilder<Entity>) => IQueryBuilder<Entity>), parameters?: Record<string, any>): this;
    orWhere(condition: string | object | ((qb: IQueryBuilder<Entity>) => IQueryBuilder<Entity>), parameters?: Record<string, any>): this;
    having(condition: string, parameters?: any[]): this;
    andHaving(condition: string, parameters?: any[]): this;
    orHaving(condition: string, parameters?: any[]): this;
    private applyHavingConditions;
    groupBy(field: string): this;
    addGroupBy(field: string): this;
    orderBy(field: string, order?: 'ASC' | 'DESC'): this;
    addOrderBy(field: string, order?: 'ASC' | 'DESC'): this;
    limit(limit?: number): this;
    offset(offset?: number): this;
    take(take?: number): this;
    skip(skip?: number): this;
    getQuery(): string;
    getSql(): string;
    getParameters(): any;
    getCount(): Promise<number>;
    getRawMany(): Promise<any[]>;
    getMany(): Promise<Entity[]>;
    getOne(): Promise<Entity | null>;
    getRawOne(): Promise<any>;
    getManyAndCount(): Promise<[Entity[], number]>;
    private applyRelationsToQueryBuilder;
}
